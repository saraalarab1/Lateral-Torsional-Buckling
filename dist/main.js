/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"update_applied_displacement\": () => (/* binding */ update_applied_displacement),\n/* harmony export */   \"update_beam_depth\": () => (/* binding */ update_beam_depth),\n/* harmony export */   \"update_beam_height\": () => (/* binding */ update_beam_height),\n/* harmony export */   \"update_beam_length\": () => (/* binding */ update_beam_length),\n/* harmony export */   \"update_left\": () => (/* binding */ update_left),\n/* harmony export */   \"update_load_position\": () => (/* binding */ update_load_position),\n/* harmony export */   \"update_right\": () => (/* binding */ update_right)\n/* harmony export */ });\n/* harmony import */ var _physics_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./physics.js */ \"./src/physics.js\");\n\n\nlet beamLength = 20;\n\nlet params = {\n    length: beamLength, // beam length (m)\n    depth: 0.2,\n    height: 1.5,\n    left: 'Pin',\n    right: 'Fixed',\n    applied_load: 0,\n    load_position: 10,\n    youngs_modulus: 215,\n    colour_by: 'Bending Moment',\n    np: 100, // number of points along beam\n    displacement_control: true,\n    displacement: new THREE.Vector3(0, 0.25, 0),\n}\nlet pin_radius;\npin_radius = 1;\nlet font;\nlet BMD,SFD,box;\n\nlet beam_offset = new THREE.Vector3(0, 4, -10);\nlet scene;\nlet lut;\n// let cooltowarm = new Lut(\"cooltowarm\", 512); // options are rainbow, cooltowarm and blackbody\n// let cooltowarm = new THREE.Lut('cooltowarm', 512); // options are rainbow, cooltowarm and blackbody\nvar cooltowarm = {};\n\n// Define the color map\ncooltowarm.colorMap = [\n  [0, 0, 1],   // Blue\n  [1, 1, 1],   // White\n  [1, 0, 0]    // Red\n];\n\n// Define the min and max values for the LUT\ncooltowarm.minValue = 0;\ncooltowarm.maxValue = 1;\n\n// Define a function to set the min value for the LUT\ncooltowarm.setMin = function(minValue) {\n  this.minValue = minValue;\n};\n\n// Define a function to set the max value for the LUT\ncooltowarm.setMax = function(maxValue) {\n  this.maxValue = maxValue;\n};\n\n// Define a function to get the color value for a given index\ncooltowarm.getColor = function(index) {\n  if (typeof index !== 'number') {\n    console.error('Invalid index: ' + index);\n    return null;\n  }\n  if (isNaN(index)) {\n    index = 0;\n  }\n\n  var colorIndex = Math.floor((index - this.minValue) / (this.maxValue - this.minValue) * (this.colorMap.length - 1));\n  if (colorIndex < 0 || colorIndex >= this.colorMap.length) {\n    return {\n      isColor: true,\n      r: 1,\n      g: 1,\n      b: 1\n    };\n  }\n  return {\n    isColor: true,\n    r: this.colorMap[colorIndex][0],\n    g: this.colorMap[colorIndex][1],\n    b: this.colorMap[colorIndex][2]\n  };\n};\n\n\n\nwindow.onload = function() {\n\n    scene = document.querySelector('a-scene');\n    const entity = document.createElement('a-entity');\n    const group = new THREE.Group();\n\n    // Create the left_support entity\n    const leftSupport = document.createElement('a-entity');\n    leftSupport.setAttribute('left_support', '');\n    leftSupport.setAttribute(\"id\", \"left_support\");\n\n    // Create the beam entity\n    const beam = document.createElement('a-entity');\n    beam.setAttribute('beam', '');\n    beam.setAttribute(\"id\", \"beam\")\n\n    // Create the right_support entity\n    const rightSupport = document.createElement('a-entity');\n    rightSupport.setAttribute('right_support', '');\n    rightSupport.setAttribute(\"id\", \"right_support\");\n\n    // Add the Three.js objects of each entity to the group\n    group.add(leftSupport.object3D.el.object3D);\n    group.add(beam.object3D.el.object3D);\n    group.add(rightSupport.object3D.el.object3D);\n\n    entity.appendChild(leftSupport);\n    entity.appendChild(beam);\n    entity.appendChild(rightSupport);\n\n    entity.setAttribute('object3D', { threeObject: group });\n\n    scene.appendChild(entity);\n\n    let flexContainer = document.querySelector(\"#dimensions\");\n    \n    let lengthLabel = document.createElement(\"a-gui-label\");\n        lengthLabel.setAttribute(\"width\", \"2.5\");\n        lengthLabel.setAttribute(\"height\", \"0.75\");\n        lengthLabel.setAttribute(\"value\", \"Length\");\n        lengthLabel.setAttribute(\"font-size\", \"0.35\");\n        lengthLabel.setAttribute(\"line-height\", \"0.8\");\n\n    let lengthSlider = document.createElement(\"a-gui-slider\");\n        lengthSlider.setAttribute(\"id\", \"lengthSlider\");\n        lengthSlider.setAttribute(\"width\", \"2.5\");\n        lengthSlider.setAttribute(\"height\", \"0.75\");\n        lengthSlider.setAttribute(\"slider-length\",\"\");\n        lengthSlider.setAttribute(\"percent\",(params.length - 6) / (50 - 5));\n        lengthSlider.setAttribute(\"position\", \"0 0 0.1\");\n    // lengthSlider.addEventListener('onChange', update_beam_length())\n    let heightLabel = document.createElement(\"a-gui-label\");\n        heightLabel.setAttribute(\"width\", \"2.5\");\n        heightLabel.setAttribute(\"height\", \"0.75\");\n        heightLabel.setAttribute(\"value\", \"Height\");\n        heightLabel.setAttribute(\"font-size\", \"0.35\");\n        heightLabel.setAttribute(\"line-height\", \"0.8\");\n        heightLabel.setAttribute(\"position\", \"0 0 0\");\n\n    let heightSlider = document.createElement(\"a-gui-slider\");\n        heightSlider.setAttribute(\"id\", \"heightSlider\");\n        heightSlider.setAttribute(\"width\", \"2.5\");\n        heightSlider.setAttribute(\"height\", \"0.75\");\n        heightSlider.setAttribute(\"onclick\", update_beam_height);\n        heightSlider.setAttribute(\"percent\", (params.height - 0.2) / (1.5 - 0.1));\n        heightSlider.setAttribute(\"position\", \"0 1 0.1\");\n\n          \n    let depthLabel = document.createElement(\"a-gui-label\");\n        depthLabel.setAttribute(\"width\", \"2.5\");\n        depthLabel.setAttribute(\"height\", \"0.75\");\n        depthLabel.setAttribute(\"value\", \"Depth\");\n        depthLabel.setAttribute(\"font-size\", \"0.35\");\n        depthLabel.setAttribute(\"line-height\", \"0.8\");\n        depthLabel.setAttribute(\"position\", \"0 0 0\");\n\n    let depthSlider = document.createElement(\"a-gui-slider\");\n        depthSlider.setAttribute(\"id\", \"depthSlider\");\n        depthSlider.setAttribute(\"width\", \"2.5\");\n        depthSlider.setAttribute(\"height\", \"0.75\");\n        depthSlider.setAttribute(\"onclick\", update_beam_depth);\n        depthSlider.setAttribute(\"percent\", params.depth);\n        depthSlider.setAttribute(\"position\", \"0 -2 0.1\");\n\n    flexContainer.appendChild(lengthLabel)\n    flexContainer.appendChild(lengthSlider)\n    flexContainer.appendChild(heightLabel)\n    flexContainer.appendChild(heightSlider)\n    flexContainer.appendChild(depthLabel)\n    flexContainer.appendChild(depthSlider)\n\n    let flexContainer2 = document.querySelector(\"#load\");\n\n    let loadPositionLabel = document.createElement(\"a-gui-label\");\n        loadPositionLabel.setAttribute(\"width\", \"2.5\");\n        loadPositionLabel.setAttribute(\"height\", \"0.75\");\n        loadPositionLabel.setAttribute(\"value\", \"Load Position\");\n        loadPositionLabel.setAttribute(\"font-size\", \"0.35\");\n        loadPositionLabel.setAttribute(\"line-height\", \"0.8\");\n        loadPositionLabel.setAttribute(\"position\", \"0 0 0\");\n\n    let loadPositionSlider = document.createElement(\"a-gui-slider\");\n        loadPositionSlider.setAttribute(\"id\", \"depthSlider\");\n        loadPositionSlider.setAttribute(\"width\", \"2.5\");\n        loadPositionSlider.setAttribute(\"height\", \"0.75\");\n        loadPositionSlider.setAttribute(\"onclick\", update_load_position);\n        loadPositionSlider.setAttribute(\"percent\", (params.length - 6) / (50 - 5));\n        loadPositionSlider.setAttribute(\"position\", \"0 1 0.1\");\n\n    flexContainer2.appendChild(loadPositionLabel)\n    flexContainer2.appendChild(loadPositionSlider)\n\n}\n\nfunction update_beam_length(click, percent) {\n  percent = ((percent * (50 - 5)) + 5).toFixed(1);\n  params.length = percent;\n  console.log(percent)\n\n    document.getElementById('beam').setAttribute('beam', {\n        length: params.length,\n        height: params.height,\n        depth: params.depth,\n    });\n    document.getElementById('right_support').setAttribute('right_support', {\n        support_type: params.right,\n        length: params.length,\n        height: params.height,\n        depth: params.depth,\n    });\n    document.getElementById('left_support').setAttribute('left_support', {\n        support_type: params.left,\n        length: params.length,\n        height: params.height,\n        depth: params.depth,\n    });\n    document.getElementById('beam').setAttribute('percent', params.length);\n}\n\nfunction update_beam_height(click,percent) {\n  percent = ((percent * (1.5 - 0.1)) + 0.1).toFixed(1);\n  params.height = percent;\n  console.log(percent)\n\n    document.getElementById('beam').setAttribute('beam', {\n        length: params.length,\n        height: params.height,\n        depth: params.depth\n    });\n    document.getElementById('right_support').setAttribute('right_support', {\n        support_type: params.right,\n        length: params.length,\n        height: params.height,\n        depth: params.depth,\n    });\n    document.getElementById('left_support').setAttribute('left_support', {\n        support_type: params.left,\n        length: params.length,\n        height: params.height,\n        depth: params.depth,\n    });\n}\n\nfunction update_beam_depth(click,percent) {\n    percent = percent.toFixed(2);\n    params.depth = percent;\n    console.log(percent)\n\n    document.getElementById('beam').setAttribute('beam', {\n        length: params.length,\n        height: params.height,\n        depth: params.depth\n    });\n    document.getElementById('right_support').setAttribute('right_support', {\n        support_type: params.right,\n        length: params.length,\n        height: params.height,\n        depth: params.depth,\n    });\n    document.getElementById('left_support').setAttribute('left_support', {\n        support_type: params.left,\n        length: params.length,\n        height: params.height,\n        depth: params.depth,\n    });\n}\n\n\nfunction update_applied_displacement(click, percent) {\n  percent = (percent * 0.5).toFixed(4);\n  params.displacement.y = percent;\n  console.log(percent)\n\n  document.getElementById('beam').setAttribute('beam', {\n    applied_displacement: params.displacement.y,\n});\n\n}\n\nfunction update_load_position(click, percent) {\n  percent = ((percent * (20 - 1)) + 1).toFixed(2);\n  params.load_position = percent;\n  console.log(percent)\n\n  document.getElementById('beam').setAttribute('beam', {\n    load_position: params.load_position,\n});\n\n}\n\nfunction update_left(value) {\n  params.left = value;\n  document.getElementById('left_support').setAttribute('left_support', {\n      support_type: params.left,\n      length: params.length,\n      height: params.height,\n      depth: params.depth,\n  });\n}\n\nfunction update_right(value) {\n  params.right = value;\n  document.getElementById('right_support').setAttribute('right_support', {\n      support_type: params.right,\n      length: params.length,\n      height: params.height,\n      depth: params.depth,\n  });\n}\n\nfunction redraw_beam(beam) {\n  console.log(\"redraw beam\")\n\n  _physics_js__WEBPACK_IMPORTED_MODULE_0__.updateDeformation(params);\n  beam.geometry.addAttribute('position', new THREE.BufferAttribute(_physics_js__WEBPACK_IMPORTED_MODULE_0__.positions, 3));\n  beam.geometry.attributes.position.needsUpdate = true;\n\n  if (params.colour_by === 'None') {\n      let colors = [];\n      for (let i = 0; i < _physics_js__WEBPACK_IMPORTED_MODULE_0__.shear_force.length; i++) {\n          colors.push(1, 1, 1);\n      }\n\n      beam.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n      beam.geometry.attributes.color.needsUpdate = true;\n      beam.material.needsUpdate = true;\n  } else {\n      let arr, max_val;\n      if (params.colour_by === 'Bending Moment') {\n          arr = _physics_js__WEBPACK_IMPORTED_MODULE_0__.bending_moment;\n          lut = cooltowarm;\n          max_val = _physics_js__WEBPACK_IMPORTED_MODULE_0__.M_max;\n      }\n      else if (params.colour_by === 'Shear Force') {\n          arr = _physics_js__WEBPACK_IMPORTED_MODULE_0__.shear_force;\n          lut = cooltowarm;\n          max_val = _physics_js__WEBPACK_IMPORTED_MODULE_0__.SF_max;\n      }\n      const colors = [];\n\n      if (max_val > 0) {\n          lut.setMin(-max_val);\n          lut.setMax(max_val);\n          for (let i = 0; i < arr.length; i++) {\n              const colorValue = arr[i];\n              const color = lut.getColor(colorValue);\n              colors.push(color.r, color.g, color.b);\n          }\n      } else {\n          for (let i = 0; i < arr.length; i++) {\n              colors.push(0, 0, 0);\n          }\n      }\n      beam.geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n      beam.geometry.attributes.color.needsUpdate = true;\n      beam.material.needsUpdate = true;\n\n  }\n\n}\n\nAFRAME.registerComponent('slider-length',{\n    init: function () {\n\n    console.log(\"***\")\n    // Get the target element to add the listener to\n    const el = this.el;\n\n    // Add the onchange listener to the target element\n    // el.addEventListener('onClick', function (event) {\n    //     console.log(\"***\")\n    //     var percent = el.getAttribute('percent');\n    //     console.log('Slider value changed to ' + percent);\n    // });\n\n    \n    },\n    update: function(){\n        const el = this.el;\n\n        console.log(\"***\")\n        var percent = el.getAttribute('percent');\n        console.log('Slider value changed to ' + percent);\n    }\n   \n})\n\nAFRAME.registerComponent('beam', {\n    schema: {\n        length: { type: 'number', default: params.length },\n        height: { type: 'number', default: params.height },\n        depth: { type: 'number', default: params.depth },\n        applied_displacement: { type: 'number', default: params.displacement.y },\n        load_position: { type: 'number', default: params.load_position },\n    },\n\n    /**\n     * Initial creation and setting of the mesh.\n     */\n    init: function() {\n        var data = this.data;\n        var el = this.el;\n        // Create geometry.\n        this.geometry = new THREE.BoxBufferGeometry(1, 1, 1, params.np, 1, 1);\n\n        // Create material.\n        this.material = new THREE.MeshStandardMaterial({ color: 0xcccccc, vertexColors: true });\n\n        // Create mesh.\n        this.mesh = new THREE.Mesh(this.geometry, this.material);\n        this.mesh.scale.set(data.length, data.height, data.depth);\n        this.mesh.position.add(beam_offset); // move the beam away from the start location\n\n        const type = 'beam';\n        this.mesh.userData.type = type; // this sets up interaction group for controllers\n\n        _physics_js__WEBPACK_IMPORTED_MODULE_0__.set_initial_position(this.mesh.geometry.attributes.position.array);\n        // Set mesh on entity.\n        el.setObject3D('mesh', this.mesh);\n    },\n    update: function() {\n        var data = this.data;\n\n        this.mesh.scale.set(data.length, data.height, data.depth);\n        console.log('updating')\n        params.length = data.length\n        params.height = data.height\n        params.depth = data.depth\n        redraw_beam(this.mesh);\n\n    },\n\n});\n\nAFRAME.registerComponent('right_support', {\n    schema: {\n        support_type: { type: 'string', default: params.right },\n        length: { type: 'number', default: params.length },\n        height: { type: 'number', default: params.height },\n        depth: { type: 'number', default: params.depth },\n    },\n\n    /**\n     * Initial creation and setting of the mesh.\n     */\n    init: function() {\n        var data = this.data;\n        var el = this.el;\n\n        let pin_geometry = new THREE.CylinderBufferGeometry(pin_radius, pin_radius, data.depth + 2 * pin_radius, 20, 32);\n        let fixed_geometry = new THREE.BoxBufferGeometry(pin_radius, data.height + 2 * pin_radius, data.depth + 2 * pin_radius);\n        let support_material = new THREE.MeshStandardMaterial({ color: 0xcccccc, vertexColors: false });\n\n        if (data.support_type == 'Pin') {\n            this.mesh = new THREE.Mesh(pin_geometry, support_material);\n            this.mesh.position.set(data.length / 2., -data.height / 2 - pin_radius, 0);\n            this.mesh.position.add(beam_offset);\n            this.mesh.rotation.x = Math.PI / 2.;\n        } else if (data.support_type === 'Fixed') {\n            this.mesh = new THREE.Mesh(fixed_geometry, support_material);\n\n            this.mesh.position.set(data.length / 2. + pin_radius / 2., 0, 0);\n            this.mesh.position.add(beam_offset);\n        } else if (data.support_type === 'Free') {\n            let material = support_material.clone();\n            material.transparent = true;\n            material.opacity = 0.3;\n            this.mesh = new THREE.Mesh(fixed_geometry, material);\n\n            this.mesh.position.set(data.length / 2., -data.height / 2 - pin_radius, 0);\n            this.mesh.position.add(beam_offset);\n            this.mesh.rotation.x = Math.PI / 2.;\n\n        }\n        this.mesh.name = 'Right Support'\n        this.mesh.userData.type = 'right_support'; // this sets up interaction group for controllers\n        // Set mesh on entity.\n        el.setObject3D('mesh', this.mesh);\n    },\n    update: function() {\n        var data = this.data;\n        var el = this.el;\n\n        let pin_geometry = new THREE.CylinderBufferGeometry(pin_radius, pin_radius, data.depth + 2 * pin_radius, 20, 32);\n        let fixed_geometry = new THREE.BoxBufferGeometry(pin_radius, data.height + 2 * pin_radius, data.depth + 2 * pin_radius);\n        let support_material = new THREE.MeshStandardMaterial({ color: 0xcccccc, vertexColors: false });\n\n        if (data.support_type == 'Pin') {\n            this.mesh = new THREE.Mesh(pin_geometry, support_material);\n            this.mesh.position.set(data.length / 2., -data.height / 2 - pin_radius, 0);\n            this.mesh.position.add(beam_offset);\n            this.mesh.rotation.x = Math.PI / 2.;\n        } else if (data.support_type === 'Fixed') {\n            this.mesh = new THREE.Mesh(fixed_geometry, support_material);\n\n            this.mesh.position.set(data.length / 2. + pin_radius / 2., 0, 0);\n            this.mesh.position.add(beam_offset);\n        } else if (data.support_type === 'Free') {\n            let material = support_material.clone();\n            material.transparent = true;\n            material.opacity = 0.3;\n            this.mesh = new THREE.Mesh(fixed_geometry, material);\n\n            this.mesh.position.set(data.length / 2., -data.height / 2 - pin_radius, 0);\n            this.mesh.position.add(beam_offset);\n            this.mesh.rotation.x = Math.PI / 2.;\n\n        }\n        this.mesh.name = 'Right Support'\n        this.mesh.userData.type = 'right_support'; // this sets up interaction group for controllers\n        // Set mesh on entity.\n        el.setObject3D('mesh', this.mesh);\n        // updateDeformation(params);\n\n    },\n});\n\nAFRAME.registerComponent('left_support', {\n    schema: {\n        support_type: { type: 'string', default: params.left },\n        length: { type: 'number', default: params.length },\n        height: { type: 'number', default: params.height },\n        depth: { type: 'number', default: params.depth },\n    },\n\n    /**\n     * Initial creation and setting of the mesh.\n     */\n    init: function() {\n        var data = this.data;\n        var el = this.el;\n\n        let pin_geometry = new THREE.CylinderBufferGeometry(pin_radius, pin_radius, data.depth + 2 * pin_radius, 20, 32);\n        let fixed_geometry = new THREE.BoxBufferGeometry(pin_radius, data.height + 2 * pin_radius, data.depth + 2 * pin_radius);\n        let support_material = new THREE.MeshStandardMaterial({ color: 0xcccccc, vertexColors: false });\n\n        if (data.support_type == 'Pin') {\n            this.mesh = new THREE.Mesh(pin_geometry, support_material);\n\n            this.mesh.position.set(-data.length / 2., -data.height / 2 - pin_radius, 0);\n            this.mesh.position.add(beam_offset);\n            this.mesh.rotation.x = Math.PI / 2.;\n        } else if (data.support_type === 'Fixed') {\n            this.mesh = new THREE.Mesh(fixed_geometry, support_material);\n\n            this.mesh.position.set(-data.length / 2. - pin_radius / 2., 0, 0);\n            this.mesh.position.add(beam_offset);\n        } else if (data.support_type === 'Free') {\n            let material = support_material.clone();\n            material.transparent = true;\n            material.opacity = 0.3;\n            this.mesh = new THREE.Mesh(fixed_geometry, material);\n\n            this.mesh.position.set(-data.length / 2., -data.height / 2 - pin_radius, 0);\n            this.mesh.position.add(beam_offset);\n            this.mesh.rotation.x = Math.PI / 2.;\n        }\n        this.mesh.name = 'Left support'\n        this.mesh.userData.type = 'left_support'; // this sets up interaction group for controllers\n        // Set mesh on entity.\n        el.setObject3D('mesh', this.mesh);\n    },\n    update: function() {\n        var data = this.data;\n        var el = this.el;\n\n        let pin_geometry = new THREE.CylinderBufferGeometry(pin_radius, pin_radius, data.depth + 2 * pin_radius, 20, 32);\n        let fixed_geometry = new THREE.BoxBufferGeometry(pin_radius, data.height + 2 * pin_radius, data.depth + 2 * pin_radius);\n        let support_material = new THREE.MeshStandardMaterial({ color: 0xcccccc, vertexColors: false });\n\n        if (data.support_type == 'Pin') {\n            this.mesh = new THREE.Mesh(pin_geometry, support_material);\n\n            this.mesh.position.set(-data.length / 2., -data.height / 2 - pin_radius, 0);\n            this.mesh.position.add(beam_offset);\n            this.mesh.rotation.x = Math.PI / 2.;\n        } else if (data.support_type === 'Fixed') {\n            this.mesh = new THREE.Mesh(fixed_geometry, support_material);\n\n            this.mesh.position.set(-data.length / 2. - pin_radius / 2., 0, 0);\n            this.mesh.position.add(beam_offset);\n        } else if (data.support_type === 'Free') {\n            let material = support_material.clone();\n            material.transparent = true;\n            material.opacity = 0.3;\n            this.mesh = new THREE.Mesh(fixed_geometry, material);\n\n            this.mesh.position.set(-data.length / 2., -data.height / 2 - pin_radius, 0);\n            this.mesh.position.add(beam_offset);\n            this.mesh.rotation.x = Math.PI / 2.;\n        }\n        this.mesh.name = 'Left support'\n        this.mesh.userData.type = 'left_support'; // this sets up interaction group for controllers\n        // Set mesh on entity.\n        el.setObject3D('mesh', this.mesh);\n    }\n});\n\n\nfunction animate() {\n  requestAnimationFrame( animate );\n  render();\n  controls.update();\n}\n\n//# sourceURL=webpack://lateral-torsional-buckling/./src/index.js?");

/***/ }),

/***/ "./src/physics.js":
/*!************************!*\
  !*** ./src/physics.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"M_max\": () => (/* binding */ M_max),\n/* harmony export */   \"P\": () => (/* binding */ P),\n/* harmony export */   \"P_max\": () => (/* binding */ P_max),\n/* harmony export */   \"SF_max\": () => (/* binding */ SF_max),\n/* harmony export */   \"bending_moment\": () => (/* binding */ bending_moment),\n/* harmony export */   \"max_displacement\": () => (/* binding */ max_displacement),\n/* harmony export */   \"positions\": () => (/* binding */ positions),\n/* harmony export */   \"set_initial_position\": () => (/* binding */ set_initial_position),\n/* harmony export */   \"shear_force\": () => (/* binding */ shear_force),\n/* harmony export */   \"updateDeformation\": () => (/* binding */ updateDeformation)\n/* harmony export */ });\nlet positions, shear_force, bending_moment;\nlet initial_positions;\nlet EI;\nlet P, P_max;\nlet M_max = 0;\nlet SF_max = 0;\nlet max_displacement = 0.5;\n\nfunction set_initial_position(p) {\n    positions = p.map((x) => x); // deep copy\n    initial_positions = p;\n}\n\nfunction updateDeformation(params) {\n    let l = params.length;\n    let a = params.load_position; // distance from left to load point\n    let b = l - a; // distance from right to load point\n\n    if (params.displacement_control) {\n        EI = 1;\n        if ((params.left === 'Pin') && (params.right === 'Pin')) {\n            P = (3 * params.displacement.y * l) / (a * a * b * b) || 0;\n            P_max = (3 * max_displacement * l) / (a * a * b * b) || 0;\n            M_max = Math.abs(P_max * a * b / l);\n            SF_max = Math.max(P_max * b / l, P_max * a / l);\n        } else if ((params.left === 'Fixed') && (params.right === 'Fixed')) {\n            P = (3 * EI * l * l * l * params.displacement.y) / (a * a * a * b * b * b) || 0;\n            P_max = (3 * EI * l * l * l * max_displacement) / (a * a * a * b * b * b) || 0;\n            let R1 = P_max * b * b * (3 * a + b) / l / l / l;\n            let R2 = P_max * a * a * (3 * b + a) / l / l / l;\n            let M1 = P_max * a * b * b / l / l;\n            let M2 = P_max * a * a * b / l / l;\n            M_max = Math.max(Math.abs(M1), Math.abs(M2));\n            SF_max = Math.max(Math.abs(R1), Math.abs(R2));\n        } else if ((params.left === 'Pin') && (params.right === 'Fixed')) {\n            P = (12 * EI * l * l * l * params.displacement.y / (3 * l + a)) / (a * a * b * b * b) || 0;\n            P_max = (12 * EI * l * l * l * max_displacement / (3 * l + a)) / (a * a * b * b * b) || 0;\n            let R1 = P_max * b * b * (a + 2 * l) / (2 * l * l * l);\n            let R2 = P_max * a * (3 * l * l - a * a) / (2 * l * l * l);\n            let M1 = R1 * a; // moment at point of load\n            let M2 = P_max * a * b * (a + l) / (2 * l * l); // moment at fixed end\n            M_max = Math.max(Math.abs(M1), Math.abs(M2));\n            SF_max = Math.max(Math.abs(R1), Math.abs(R2));\n        } else if ((params.left === 'Fixed') && (params.right === 'Pin')) {\n            P = (12 * EI * l * l * l * params.displacement.y / (3 * l + b)) / (a * a * a * b * b) || 0;\n            P_max = (12 * EI * l * l * l * max_displacement / (3 * l + b)) / (a * a * a * b * b) || 0;\n            let R1 = P_max * a * a * (b + 2 * l) / (2 * l * l * l);\n            let R2 = P_max * b * (3 * l * l - b * b) / (2 * l * l * l);\n            let M1 = R1 * b; // moment at point of load\n            let M2 = P_max * b * a * (b + l) / (2 * l * l); // moment at fixed end\n            M_max = Math.max(Math.abs(M1), Math.abs(M2));\n            SF_max = Math.max(Math.abs(R1), Math.abs(R2));\n        } else if ((params.left === 'Fixed') && (params.right === 'Free')) {\n            P = (3 * EI * params.displacement.y) / (a * a * a) || 0;\n            P_max = (3 * EI * max_displacement) / (a * a * a) || 0;\n            M_max = Math.abs(P_max * a);\n            SF_max = Math.abs(P_max);\n        } else if ((params.left === 'Free') && (params.right === 'Fixed')) {\n            P = (3 * EI * params.displacement.y) / (b * b * b) || 0;\n            P_max = (3 * EI * max_displacement) / (b * b * b) || 0;\n            M_max = Math.abs(P_max * b);\n            SF_max = Math.abs(P_max);\n        } else {\n            P = 0;\n            P_max = 0;\n            M_max = 0;\n            SF_max = 0;\n        }\n        // console.log(P)\n    }\n    else {\n        EI = params.youngs_modulus * 1e9 * params.depth * Math.pow(params.height, 3) / 12; // convert from GPa to Pa\n        P = params.applied_load * 1e3; // applied load in N\n    }\n\n    // stolen from https://www.linsgroup.com/MECHANICAL_DESIGN/Beam/beam_formula.htm\n\n    let deflection;\n    bending_moment = [];\n    shear_force = [];\n\n    for (let i = 0; i < positions.length / 3; i++) {\n        let x = l * positions[i * 3 + 0] + l / 2; // distance along beam\n\n        if ((params.left === 'Pin') && (params.right === 'Pin')) {\n            // SIMPLY SUPPORTED BEAM --- IMPLEMENTED AND WORKING\n            if (x < a) {\n                deflection = P * b * x * (l * l - b * b - x * x) / (6 * EI * l);\n                bending_moment.push(P * b * x / l);\n                shear_force.push(P * b / l);\n            } else {\n                deflection = P * a * (l - x) * (2 * l * x - x * x - a * a) / (6 * EI * l);\n                bending_moment.push(P * a / l * (l - x));\n                shear_force.push(-P * a / l);\n            }\n        } else if ((params.left === 'Fixed') && (params.right === 'Fixed')) {\n            // IMPLEMENTED AND PROBABLY WORKING\n            let R1 = P * b * b * (3 * a + b) / l / l / l;\n            let R2 = P * a * a * (3 * b + a) / l / l / l;\n            if (x < a) {\n                deflection = P * b * b * x * x * (3 * a * l - 3 * a * x - b * x) / (6 * EI * l * l * l);\n                bending_moment.push(R1 * x - P * a * b * b / l / l);\n                shear_force.push(R1);\n            } else {\n                deflection = P * a * a * (l - x) * (l - x) * (3 * b * l - 3 * b * (l - x) - a * (l - x)) / (6 * EI * l * l * l);\n                bending_moment.push(R2 * (l - x) - P * a * a * b / l / l);\n                shear_force.push(-R2);\n            }\n        } else if ((params.left === 'Pin') && (params.right === 'Fixed')) {\n            // IMPLEMENTED AND PROBABLY WORKING\n            let R1 = P * b * b * (a + 2 * l) / (2 * l * l * l);\n            let R2 = P * a * (3 * l * l - a * a) / (2 * l * l * l);\n            if (x < a) {\n                deflection = P * b * b * x * (3 * a * l * l - 2 * l * x * x - a * x * x) / (12 * EI * l * l * l);\n                bending_moment.push(R1 * x);\n                shear_force.push(R1);\n            } else {\n                deflection = P * a * ((l - x) ** 2 * (3 * l * l * x - a * a * x - 2 * a * a * l)) / (12 * EI * l * l * l);\n                bending_moment.push(R1 * x - P * (x - a));\n                shear_force.push(-R2);\n            }\n        } else if ((params.left === 'Fixed') && (params.right === 'Pin')) {\n            // IMPLEMENTED AND PROBABLY WORKING\n            let R1 = P * a * a * (b + 2 * l) / (2 * l * l * l);\n            let R2 = P * b * (3 * l * l - b * b) / (2 * l * l * l);\n            if (x > a) {\n                deflection = P * a * a * (l - x) * (3 * b * l * l - 2 * l * (l - x) * (l - x) - b * (l - x) * (l - x)) / (12 * EI * l * l * l);\n                bending_moment.push(R2 * (l - x));\n                shear_force.push(-R2);\n            } else {\n                deflection = P * b * (x ** 2 * (3 * l * l * (l - x) - b * b * (l - x) - 2 * b * b * l)) / (12 * EI * l * l * l);\n                bending_moment.push(R2 * (l - x) - P * ((l - x) - b));\n                shear_force.push(R2);\n            }\n        } else if ((params.left === 'Fixed') && (params.right === 'Free')) {\n            // IMPLEMENTED AND PROBABLY WORKING\n            if (x > a) {\n                deflection = P * a * a * (3 * l - 3 * (l - x) - a) / (6 * EI);\n                bending_moment.push(0);\n                shear_force.push(0);\n            } else {\n                deflection = P * x ** 2 * (3 * a - x) / (6 * EI);\n                bending_moment.push(P * (l - x - a));\n                shear_force.push(-P);\n            }\n        } else if ((params.left === 'Free') && (params.right === 'Fixed')) {\n            // IMPLEMENTED AND PROBABLY WORKING\n            if (x < a) {\n                deflection = P * b * b * (3 * l - 3 * x - b) / (6 * EI);\n                bending_moment.push(0);\n                shear_force.push(0);\n            } else {\n                deflection = P * (l - x) ** 2 * (3 * b - l + x) / (6 * EI);\n                bending_moment.push(P * (x - a));\n                shear_force.push(-P);\n            }\n        } else {\n            deflection = 0;\n            bending_moment.push(0);\n            shear_force.push(0);\n        }\n        positions[i * 3 + 1] = initial_positions[i * 3 + 1] - deflection;\n\n    }\n}\n\n\n//# sourceURL=webpack://lateral-torsional-buckling/./src/physics.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;